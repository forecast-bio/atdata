# Issue #32: Design AppView architecture and data model

## REVIEW

Part of another issue's review.

## Verdict: ARCHIVE

## Evidence
The original vision for a standalone AppView service has been superseded by the
provider/repository architecture implemented directly in the library. Instead of
building a separate AppView service with its own data model, atdata uses a
pluggable `IndexProvider` abstraction (`SqliteProvider`, `RedisProvider`,
`PostgresProvider`) paired with a `Repository` dataclass that routes between
local and atmosphere backends. This approach is simpler, avoids an external
service dependency, and still achieves the core goal of flexible data indexing
and routing.

## Codebase References
- `src/atdata/providers/_base.py` line 21: `class IndexProvider(ABC)` -- abstract base for all providers
- `src/atdata/providers/_sqlite.py` line 65: `class SqliteProvider(IndexProvider)` -- default SQLite backend
- `src/atdata/providers/_redis.py` line 23: `class RedisProvider(IndexProvider)` -- Redis backend
- `src/atdata/providers/_postgres.py` line 65: `class PostgresProvider(IndexProvider)` -- PostgreSQL backend
- `src/atdata/providers/_factory.py` -- provider factory for instantiation
- `src/atdata/repository.py` line 36: `class Repository` -- dataclass pairing provider + data store with prefix routing
- `.planning/phases/01-atproto-foundation/04_appview.md` -- original AppView design document (now historical reference)
