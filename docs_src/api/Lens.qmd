# lens { #atdata.lens }

`lens`

Lens-based type transformations for datasets.

This module implements a lens system for bidirectional transformations between
different sample types. Lenses enable viewing a dataset through different type
schemas without duplicating the underlying data.

Key components:

- ``Lens``: Bidirectional transformation with getter (S -> V) and optional
  putter (V, S -> S)
- ``LensNetwork``: Global singleton registry for lens transformations
- ``@lens``: Decorator to create and register lens transformations

Lenses support the functional programming concept of composable, well-behaved
transformations that satisfy lens laws (GetPut and PutGet).

Example:
    >>> @packable
    ... class FullData:
    ...     name: str
    ...     age: int
    ...     embedding: NDArray
    ...
    >>> @packable
    ... class NameOnly:
    ...     name: str
    ...
    >>> @lens
    ... def name_view(full: FullData) -> NameOnly:
    ...     return NameOnly(name=full.name)
    ...
    >>> @name_view.putter
    ... def name_view_put(view: NameOnly, source: FullData) -> FullData:
    ...     return FullData(name=view.name, age=source.age,
    ...                     embedding=source.embedding)
    ...
    >>> ds = Dataset[FullData]("data.tar")
    >>> ds_names = ds.as_type(NameOnly)  # Uses registered lens

## Classes

| Name | Description |
| --- | --- |
| [Lens](#atdata.lens.Lens) | A bidirectional transformation between two sample types. |
| [LensNetwork](#atdata.lens.LensNetwork) | Global registry for lens transformations between sample types. |

### Lens { #atdata.lens.Lens }

```python
lens.Lens(get, put=None)
```

A bidirectional transformation between two sample types.

A lens provides a way to view and update data of type ``S`` (source) as if
it were type ``V`` (view). It consists of a getter that transforms ``S -> V``
and an optional putter that transforms ``(V, S) -> S``, enabling updates to
the view to be reflected back in the source.

Type Parameters:
    S: The source type, must derive from ``PackableSample``.
    V: The view type, must derive from ``PackableSample``.

Example:
    >>> @lens
    ... def name_lens(full: FullData) -> NameOnly:
    ...     return NameOnly(name=full.name)
    ...
    >>> @name_lens.putter
    ... def name_lens_put(view: NameOnly, source: FullData) -> FullData:
    ...     return FullData(name=view.name, age=source.age)

#### Methods

| Name | Description |
| --- | --- |
| [get](#atdata.lens.Lens.get) | Transform the source into the view type. |
| [put](#atdata.lens.Lens.put) | Update the source based on a modified view. |
| [putter](#atdata.lens.Lens.putter) | Decorator to register a putter function for this lens. |

##### get { #atdata.lens.Lens.get }

```python
lens.Lens.get(s)
```

Transform the source into the view type.

Args:
    s: The source sample of type ``S``.

Returns:
    A view of the source as type ``V``.

##### put { #atdata.lens.Lens.put }

```python
lens.Lens.put(v, s)
```

Update the source based on a modified view.

Args:
    v: The modified view of type ``V``.
    s: The original source of type ``S``.

Returns:
    An updated source of type ``S`` that reflects changes from the view.

##### putter { #atdata.lens.Lens.putter }

```python
lens.Lens.putter(put)
```

Decorator to register a putter function for this lens.

Args:
    put: A function that takes a view of type ``V`` and source of type
        ``S``, and returns an updated source of type ``S``.

Returns:
    The putter function, allowing this to be used as a decorator.

Example:
    >>> @my_lens.putter
    ... def my_lens_put(view: ViewType, source: SourceType) -> SourceType:
    ...     return SourceType(...)

### LensNetwork { #atdata.lens.LensNetwork }

```python
lens.LensNetwork()
```

Global registry for lens transformations between sample types.

This class implements a singleton pattern to maintain a global registry of
all lenses decorated with ``@lens``. It enables looking up transformations
between different ``PackableSample`` types.

Attributes:
    _instance: The singleton instance of this class.
    _registry: Dictionary mapping ``(source_type, view_type)`` tuples to
        their corresponding ``Lens`` objects.

#### Methods

| Name | Description |
| --- | --- |
| [register](#atdata.lens.LensNetwork.register) | Register a lens as the canonical transformation between two types. |
| [transform](#atdata.lens.LensNetwork.transform) | Look up the lens transformation between two sample types. |

##### register { #atdata.lens.LensNetwork.register }

```python
lens.LensNetwork.register(_lens)
```

Register a lens as the canonical transformation between two types.

Args:
    _lens: The lens to register. Will be stored in the registry under
        the key ``(_lens.source_type, _lens.view_type)``.

Note:
    If a lens already exists for the same type pair, it will be
    overwritten.

##### transform { #atdata.lens.LensNetwork.transform }

```python
lens.LensNetwork.transform(source, view)
```

Look up the lens transformation between two sample types.

Args:
    source: The source sample type (must derive from ``PackableSample``).
    view: The target view type (must derive from ``PackableSample``).

Returns:
    The registered ``Lens`` that transforms from ``source`` to ``view``.

Raises:
    ValueError: If no lens has been registered for the given type pair.

Note:
    Currently only supports direct transformations. Compositional
    transformations (chaining multiple lenses) are not yet implemented.

## Functions

| Name | Description |
| --- | --- |
| [lens](#atdata.lens.lens) | Decorator to create and register a lens transformation. |

### lens { #atdata.lens.lens }

```python
lens.lens(f)
```

Decorator to create and register a lens transformation.

This decorator converts a getter function into a ``Lens`` object and
automatically registers it in the global ``LensNetwork`` registry.

Args:
    f: A getter function that transforms from source type ``S`` to view
        type ``V``. Must have exactly one parameter with a type annotation.

Returns:
    A ``Lens[S, V]`` object that can be called to apply the transformation
    or decorated with ``@lens_name.putter`` to add a putter function.

Example:
    >>> @lens
    ... def extract_name(full: FullData) -> NameOnly:
    ...     return NameOnly(name=full.name)
    ...
    >>> @extract_name.putter
    ... def extract_name_put(view: NameOnly, source: FullData) -> FullData:
    ...     return FullData(name=view.name, age=source.age)